@using Protobuf.Decode.Parser
<li id="node-@Node.Path.Replace(".", "-").Replace("[", "_").Replace("]", "_")" 
    class="tree-node @(GetNodeClasses()) @(IsSelected ? "selected" : string.Empty) @(IsExpanded ? "expanded" : "collapsed") @(IsSearchHighlight ? "search-highlight" : string.Empty) @(IsCurrentSearch ? "search-current" : string.Empty)">
    @if (Node.Children.Count > 0)
    {
        <div class="node-header">
            <span class="label expandable" @onclick="ToggleAndSelect">
                <span class="expander-icon @(GetWireTypeClass())">@(IsExpanded ? "â–¾" : "â–¸")</span>
                <span class="field-number @(GetWireTypeClass())">@Node.FieldDisplay @(IsCurrentSearch ? "ğŸŸ " : "")</span>
                <span class="node-details">
                    <span class="wire-type @(GetDetailClass())">@Node.WireType</span>
                    <span class="summary @(GetDetailClass())">
                        @GetFormattedSummary()
                    </span>
                </span>
            </span>
        </div>

        @if (IsExpanded)
        {
            <ul class="tree-children">
                @foreach (var child in Node.Children)
                {
                    var childIsCurrentSearch = !string.IsNullOrEmpty(CurrentSearchPath) && child.Path == CurrentSearchPath;
                    @if (childIsCurrentSearch)
                    {
                        <text><!-- MATCH! CurrentSearchPath=@CurrentSearchPath, child.Path=@child.Path --></text>
                    }
                    <ProtoTreeViewNode Node="child"
                                       OnSelect="OnSelect"
                                       ExpandedState="ExpandedState"
                                       SelectedPath="SelectedPath"
                                       IsSelected="SelectedPath == child.Path"
                                       SearchMatches="SearchMatches"
                                       CurrentSearchPath="CurrentSearchPath"
                                       IsSearchHighlight="SearchMatches.Contains(child.Path)"
                                       IsCurrentSearch="childIsCurrentSearch" />
                }
            </ul>
        }
    }
    else
    {
        <div class="node-header">
            <span class="label leaf" @onclick="Select">
                <span class="field-number @(GetWireTypeClass())">@Node.FieldDisplay @(IsCurrentSearch ? "ğŸŸ " : "")</span>
                <span class="node-details">
                    <span class="wire-type @(GetDetailClass())">@Node.WireType</span>
                    <span class="summary @(GetDetailClass())">
                        @GetFormattedSummary()
                    </span>
                </span>
            </span>
        </div>
    }
</li>

@code {
    [CascadingParameter] public ProtoTreeView Root { get; set; } = default!;
    [Parameter] public ProtoDisplayNode Node { get; set; } = default!;
    [Parameter] public EventCallback<ProtoDisplayNode> OnSelect { get; set; }
    [Parameter] public Dictionary<string, bool> ExpandedState { get; set; } = default!;
    [Parameter] public string SelectedPath { get; set; } = string.Empty;
    [Parameter] public bool IsSelected { get; set; }
    [Parameter] public bool IsFirstNode { get; set; }
    [Parameter] public int TotalNodeCount { get; set; }
    [Parameter] public List<string> SearchMatches { get; set; } = new();
    [Parameter] public string CurrentSearchPath { get; set; } = string.Empty;
    [Parameter] public bool IsSearchHighlight { get; set; }
    [Parameter] public bool IsCurrentSearch { get; set; }

    private bool IsExpanded => ExpandedState.GetValueOrDefault(Node.Path);

    private void Toggle()
    {
        ExpandedState[Node.Path] = !IsExpanded;
    }

    private Task Select() => OnSelect.InvokeAsync(Node);

    private async Task ToggleAndSelect()
    {
        Toggle();
        await Select();
    }

    private string GetWireTypeClass()
        => Node.WireType switch
        {
            ProtoWireType.Varint => "wire-varint",
            ProtoWireType.LengthDelimited => "wire-length",
            ProtoWireType.Fixed32 => "wire-fixed32",
            ProtoWireType.Fixed64 => "wire-fixed64",
            _ => "wire-unknown"
        };

    private string GetNodeClasses()
        => Node.IsArrayGroup
            ? "is-array-group"
            : (Node.Children.Count > 0 ? "has-children" : string.Empty);

    private string GetDetailClass()
    {
        if (Node.IsArrayGroup)
        {
            return "wire-array";
        }

        if (Node.Children.Count > 0)
        {
            return "wire-nested";
        }

        return GetWireTypeClass();
    }

    private string GetFormattedSummary()
    {
        if (!IsFirstNode || TotalNodeCount == 0)
        {
            return Node.Summary;
        }

        // ä» Summary ä¸­æå–é•¿åº¦ä¿¡æ¯
        var summary = Node.Summary;
        var lengthMatch = System.Text.RegularExpressions.Regex.Match(summary, @"é•¿åº¦\s*(\d+)");
        var length = lengthMatch.Success ? lengthMatch.Groups[1].Value : "0";

        if (Node.IsArrayGroup)
        {
            // æ•°ç»„æ ¼å¼: æ•°ç»„ Â· {count} Â· èŠ‚ç‚¹æ€»æ•° Â· {totalCount} Â· é•¿åº¦ Â· {length}
            return $"æ•°ç»„ Â· {Node.Children.Count} Â· èŠ‚ç‚¹æ€»æ•° Â· {TotalNodeCount} Â· é•¿åº¦ Â· {length}";
        }
        else if (Node.Children.Count > 0)
        {
            // åµŒå¥—ç±»æ ¼å¼: åµŒå¥—ç±» Â· {count} Â· èŠ‚ç‚¹æ€»æ•° Â· {totalCount} Â· é•¿åº¦ Â· {length}
            return $"åµŒå¥—ç±» Â· {Node.Children.Count} å­èŠ‚ç‚¹ Â· èŠ‚ç‚¹æ€»æ•° Â· {TotalNodeCount} Â· é•¿åº¦ Â· {length}";
        }
        else
        {
            // å¶å­èŠ‚ç‚¹: ä¿æŒåŸæ · + èŠ‚ç‚¹æ€»æ•°
            return $"{summary} Â· èŠ‚ç‚¹æ€»æ•° Â· {TotalNodeCount}";
        }
    }
}

